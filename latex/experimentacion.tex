En esta sección, se detallan los diferentes experimentos que realizamos para medir el funcionamiento, la eficiencia y calidad de resultados, tanto de forma cuantitativa como cualitativa, de los métodos implementados.

Para lograr tal fin realizamos los siguientes tipos de experimentos:
\begin{itemize}
  \item Funcionamiento de los métodos implementados: mostraremos que los métodos de interpolación funcionan correctamente comparandolos contra diferentes familias de funciones.
  \item Determinación del tamaño de bloque del método interpolación por splines.
  \item Medición del ECM y PSNR de los métodos.
  \item Medición de los tiempos de ejecución de los métodos.
  \item Análisis cualitativos de los métodos, fenómeno de artifacts.
\end{itemize}

Los videos utilizados para los diversos experimentos, fueron los siguientes:

\begin{itemize}
  \item \textbf{Video 1 - Skate}: 426x240, cantidad de cuadros originales: 151 , fps: 30, duracion: 5s.
  \item \textbf{Video 2 - Messi}: 426x240, cantidad de cuadros originales: 151, fps: 30, duracion: 5s.
  \item \textbf{Video 3 - Amanecer}: 426x240, cantidad de cuadros originales: 151, fps: 30, duracion: 5s.
\end{itemize}

Es importante mencionar que cada video representa una clase de video distinto, en donde el Video 1 contiene movimientos bruscos, el Video 2 cambios de camara, y el Video 3 movimientos suaves.

El motivo de estas elecciones se debe a la busqueda de diversos \textit{artifacts} a partir de las caracteristicas de cada clase.

\subsection{Detalles generales de la experimentación}

\begin{itemize}
    \item En los experimentos que se utilizaron números aleatorios, se generaron utilizando la función \textit{rand}, provista por la librería \texttt{stdlib.h}.
    \item La semilla para los números aleatorios se seteo utilizando el método \textit{srand(time(NULL))}, para evitar repeticiones de números en diferentes corridas.
    \item Las instancias de prueba fueron generadas con los archivos provistos por la cátedra. Adicionalmente, hicimos nuestras propias instancias emulando diferentes funciones (por ejemplo una función constante, lineal y cuadrática) para realizar el control de calidad de los métodos.
    \item Para medir los tiempos utilizamos la librería \textit{chrono} y medimos los resultados en nanosegundos.
    \item A su vez, utilizamos el nivel de optimización \textit{O2} de \textit{C++} a la hora de compilar el código.
    \item Todos los tests fueron corridos en la misma máquina bajo las mismas condiciones.
\end{itemize}


\subsection{Funcionamiento de los métodos implementados}
En este experimento nuestro objetivo fue asegurarnos el correcto funcionamiento de nuestra implementación de la interpolación fragmentaria lineal, interpolación por splines, e interpolación por splines con tamaño de bloque fijo, tomando bloques de 2 cuadros, 4 cuadros y 8 cuadros.

Con este fin, realizamos una serie de tests que muestran el correcto funcionamiento de cada método para distintas familias de funciones:
\begin{itemize}
  \item Función constante.
  \item Función lineal.
  \item Función cuadrática.
  \item Función cúbica.
\end{itemize}

Luego, cada método de interpolación fue testeado contra cada una de las familias de funciones mencionadas de la siguiente forma:
\begin{itemize}
  \item Dada una familia de funciones, se generan aleatoriamente los coeficientes necesarios para definir una función de esa familia, i.e.: para una constante se genera solo el coeficiente independiente, mientras que para una cuadrática se generan 3 coeficientes.
    \item Una vez generada la función, se la evalua en un rango de valores para obtener un array de valores esperados.
    \item Luego, a partir del array de valores esperados se construye otro array quitandole elementos a intervalos fijos.
        Este nuevo array será el utilizado para realizar la interpolación, y lo que testearemos es la aproximación de  la
        interpolación a los elementos que quitamos.
    \item Una vez que tenemos la interpolación con cualquiera de los métodos mencionados, basta recorrer los elementos del array de valores esperados a la vez que evaluamos la interpolación obtenida.
        Para cada par de valores: esperado e interpolado, querremos ver que la diferencia absoluta es menor que un epsilon que
        definiremos dependiendo del método utilizado y la función a interpolar.
\end{itemize}

Es importante mencionar algunas carácterísticas de las instancias utilizadas:
\begin{itemize}
    \item Cantidad de puntos generados con la función(tamaño del array de valores esperados): 100
    \item Cantidad de puntos a interpolar: 50.
    \item Todos los coeficientes generados aleatoriamente están en el rango $[1,10]$,
        para evitar que las funciones generadas crezcan de forma desmedida.
\end{itemize}

Luego, se obtuvieron las siguientes cotas de precisión para los distintos métodos y funciones:

\begin{table}[H]
    \begin{tabular}{| c | c | c | c | c |}
    \hline
    {} & F. Constante & F. Lineal & F. Cuadrática & F. Cúbica \\ \hline
    Interpolación por Vecinos & 0.0001 & 10 & 1000 & 100000 \\
    Interpolación Lineal & 0.0001 & 0.0001 & 10 & 1000 \\
    Interpolación por Splines & 0.0001 & 0.0001 & 10 & 1000 \\
    Interpolación por Splines (bloques tamaño 2) & 0.0001 & 0.0001 & 10 & 1000 \\
    Interpolación por Splines (bloques tamaño 4) & 0.0001 & 0.0001 & 10 & 1000 \\
    Interpolación por Splines (bloques tamaño 8) & 0.0001 & 0.0001 & 10 & 1000 \\
    \hline
    \end{tabular}
\end{table}

\subsection{Determinación del tamaño de bloque del método Spline}
En este experimento buscamos determinar cual es el mejor tamaño de bloque para la
 interpolación por splines con tamaño de bloque fijo, teniendo en cuenta la
  performance y la calidad de los resultados obtenidos para cada tamaño propuesto.

Planteamos los siguientes tamaños de bloques: 2 cuadros, 4 cuadros y 8 cuadros. PORQUE?

Las comparaciones que vamos a realizar seran en terminos de complejidad temporal y ECM, PSNR (ver Seccion\ref{ECM} para las definiciones de ambas metricas).
\subsubsection{Comparación complejidad temporal}
Como instancias de prueba, tomamos cada uno de los videos elegidos y fuimos aumentando la cantidad de cuadros agregados.

En los siguientes graficos mostramos los resultados obtenidos para cada tamaño de bloque:

\subsubsection{Comparacion ECM y PSNR}


\subsubsection{Conclusiones}

Habiendo hecho las comparaciones entre los diversos tamaños.

\subsection{Medición del ECM y PSNR de los métodos.}\label{ECM}
Sea $F$ un frame del vídeo real (ideal) , y $\bar{F}$ el mismo frame del vídeo efectivamente construidos por alguno de los métodos. Sea $m$ la cantidad de filas de píxeles en cada imagen y $n$ la cantidad de columnas.

Definimos el Error Cuadrático Medio, \texttt{ECM}, como el real dado por:
\begin{equation}
\texttt{ECM}(F,\bar{F}) = \frac{1}{mn}\sum_{i=1}^m\sum_{j = 1}^n |F_{k_{ij}} - \bar{F}_{k_{ij}}|^2
\end{equation}

A su vez definimos \emph{Peak to Signal Noise Ratio}, \texttt{PSNR}, como el real dado por:
\begin{equation}
\texttt{PSNR}(F,\bar{F}) = 10 \log_{10}\bigg(\frac{255^2}{\texttt{ECM}(F,\bar{F})}\bigg). \label{eq:psnr}
\end{equation}

Ambas medidas nos sirven para realizar un análisis cuantitativo de la calidad de los resultados obtenidos con los distintos métodos.

En este experimento utilizamos los videos propuestos al inicio de la experimentacion, variando la cantidad de cuadros que agregamos


Los resultados obtenidos son los siguientes: (GRÁFICO COMPARANDO LOS MÉTODOS)

\subsection{Medición de los tiempos de ejecución de los métodos}
A partir de la implementación descripta en la Sección xxx, podemos inferir una complejidad temporal para cada método:
Nuevamente, sea $m$ la cantidad de filas de píxeles en cada imagen y $n$ la cantidad de columnas, sea $c$ es la cantidad de cuadros originales y sea $f$ la cantidad de cuadros a agregar entre los originales.
\begin{itemize}
  \item Interpolacion lineal: dado que realizamos 4 ciclos, en donde el primero se ejecuta $n$ veces, el segundo $m$ veces, el tercero $c$ veces, y el cuarto $f$ veces, la complejidad temporal del mismo es $\Theta(nmcf)$.
  \item Vecino mas cercano: situación idéntica al método lineal, realizamos 4 ciclos, en donde el primero se ejecuta $n$ veces, el segundo $m$ veces, el tercero $c$ veces, y el cuarto $f$ veces, la complejidad temporal del mismo es $\Theta(nmcf)$.
  \item Interpolacion por Splines:
  \item Interpolacion por Splines con tamaño de bloque fijo:
\end{itemize}

Las instancias que utilizamos, en este caso, fueron

Los resultamos obtenidos:


\subsection{Análisis cualitativos de los métodos, fenómeno de artifacts.}
Los \textit{artifacts} son errores visuales resultantes de la aplicación de los métodos. Estos errores visuales se caracterizan por romper la coherencia entre imágenes al generar distorsiones evidentes.

\subsubsection{Artifacts: Movimientos Bruscos}

\subsubsection{Artifacts: Cambios de Camara}

\subsubsection{Artifacts: Movimientos Armonicos}
