\subsection{Interpolación por vecinos}

Este método consiste en reemplazar los cuadros intermedios a ser rellenados por el cuadro original mas cercano en el tiempo.
Es decir, dados los cuadros del video sin camara lenta, generamos otro video en camara lenta copiando los cuadros originales de la siguiente manera:

% \begin{center}
% \begin{bytefield}{16}
% \wordbox{1}{A 16-bit field} \\
% \bitbox{8}{8 bits} & \bitbox{8}{8 more bits} \\
% \wordbox{2}{A 32-bit field. Note that text wraps within the box.}
% \end{bytefield}
% \end{center}

Sean Frame1 y Frame2 dos cuadros consecutivos del video original:

\begin{center}
\begin{bytefield}{8}
\bitbox{4}{Frame1} & \bitbox{4}{Frame2}
\end{bytefield}
\end{center}

Si queremos ahora 6 cuadros entre cada 2 del archivo original lo transformamos a:

\begin{center}
\begin{bytefield}{32}
\bitbox{4}{Frame1} & \bitbox{4}{Frame1} & \bitbox{4}{Frame1} & \bitbox{4}{Frame1} & \bitbox{4}{Frame2} & \bitbox{4}{Frame2} & \bitbox{4}{Frame2} & \bitbox{4}{Frame2}
\end{bytefield}
\end{center}

El pseudocódigo sería el siguiente:

\begin{lstlisting}
Sean W,H,I el ancho, alto y la cantidad de frames del video original
Sea video[W][H][I] el triple vector de numeros enteros que representa el video original
Sea K la cantidad de frames que queremos agregar entre cuadro y cuadro

Crear un triple vector de enteros new_video[W][H][I+(I-1)*K]
Para w = 0 hasta W-1 hacer
	Para h = 0 hasta H-1 hacer
		Para i = 0 hasta I-2 hacer
			Para j = 0 hasta K/2 hacer
				new_video[w][h].push_back(video[w][h][i])
			Fin para
			Para j = (K/2)+1 hasta K hacer
				new_video[w][h].push_back(video[w][h][i+1])
			Fin para
		Fin para
		new_video[w][h].push_back(video[w][h][I-1])
	Fin para
Fin para
Devolver new_video
\end{lstlisting}

\subsection{Interpolación lineal}

En este caso, usamos el polinomio interpolador de Lagrange entre cada par de puntos/pixeles consecutivos para aproximar los valores intermedios que irían en el video de camara lenta. Esto genera una función lineal para los pixeles consecutivos en la misma posición.

Por ejemplo, sean dos pixeles con valores 1 y 4:

\begin{center}
\begin{bytefield}{8}
\bitbox{4}{1} & \bitbox{4}{4}
\end{bytefield}
\end{center}

Si queremos un video en camara lenta con 5 cuadros intermedios por cada 2 del original, estos se replicarán de la siguiente forma:

\begin{center}
\begin{bytefield}{28}
\bitbox{4}{1} & \bitbox{4}{1.5} & \bitbox{4}{2} & \bitbox{4}{2.5} & \bitbox{4}{3} & \bitbox{4}{3.5} & \bitbox{4}{4}
\end{bytefield}
\end{center}

El procedimiento es el siguiente:

\begin{lstlisting}
Sean W,H,I el ancho, alto y la cantidad de frames del video original
Sea video[W][H][I] el triple vector de numeros enteros que representa el video original
Sea K la cantidad de frames que queremos agregar entre cuadro y cuadro

Crear un triple vector de enteros new_video[W][H][I+(I-1)*K]
Para w = 0 hasta W-1 hacer
	Para h = 0 hasta H-1 hacer
		Para i = 0 hasta I-2 hacer
			coef_cero = video[w][h][i]
			coef_uno = (video[w][h][i+1] - video[w][h][i]) / (K+1);
			Para k = 0 hasta K hacer
				pixel = coef_cero + coef_uno*k;
				Si (pixel < 0) pixel = 0
				Si (pixel > 255) pixel = 255
				new_video.push_back(pixel)
		Fin para
		new_video.push_back(video[w][h][I-1])
	Fin para
Fin para
Devolver new_video
\end{lstlisting}

\subsection{Interpolación por Splines}

En este método aplicamos la técnica de Splines. Esta consiste en generar un sistema de ecuaciones para encontrar una función por partes que interpole cada par de puntos con polinomios de forma que la curva resultante sea continua y dos veces derivable. Como el sistema es tridiagonal, podemos aprovechar para guardar los valores de la matriz de forma más eficiente. El pseudocódigo es el siguiente:

\begin{lstlisting}
Sean W,H,I el ancho, alto y la cantidad de frames del video original
Sea video[W][H][I] el triple vector de numeros enteros que representa el video original
Sea K la cantidad de frames que queremos agregar entre cuadro y cuadro

Crear un triple vector de enteros new_video[W][H][I+(I-1)*K]
Para w = 0 hasta W-1 hacer
	Para h = 0 hasta H-1 hacer
		Crear un vector de enteros valores[I+(I-1)*K]
		GenerarSpline(video[w][h], valores, I, K)
		new_video[w][h] = valores
	Fin para
Fin para
Devolver new_video

GenerarSpline(y, valores, I, K):
	n = y.size()
	Crear doble vector de enteros sistema[n][2]
	sistema[0] = {1,0}
	Para j = 1 hasta n-2 hacer
		sistema[j] = {1, 4}
	Fin para
	sistema[n-1] = {0,1}
	// Factorización LU
	Para j = 1 hasta n-2 hacer
		coef = sistema[i + 1][0]/sistema[i][1];
		sistema[i + 1][0] = coef
		sistema[i + 1][1] -= coef
	Fin para
	Crear vectores x[n], a[n], b[n], c[n], d[n]
	a = y
	Para i = 1 hasta n-2 hacer
		x[i] = 3*(a[i + 1] - 2*a[i] + a[i - 1]);
		x[i] -= x[i - 1]*sistema[i][0];
	Fin para
	// Resuelvo triangular superior (Uc = x)
	Para i = n - 2 hasta 1 hacer
		c[i] = x[i];
		c[i] -= c[i + 1];
		c[i] /= sistema[i][1];
	Fin para
	// Calculo mis coeficientes "b" y "d"
	Para i = 0 hasta n-2 hacer
		b[i] = a[i + 1] - a[i] - (2*c[i] + c[i + 1])/3;
		d[i] = (c[i + 1] - c[i])/3;
	Fin para
	//Calculo los pixeles resultantes con el Spline
	Para i = 0 hasta n-1 hacer
		Para j = 0 hasta K hacer
			dif = j/(K+1)
			val = a[i] + b[i]*(dif) + c[i]*(dif)*(dif) + d[i]*(dif)*(dif)*(dif)
			valores.push_back(val)
		Fin para
	Fin para
	valores.push_back(y[n-1])
\end{lstlisting}

\subsection{Interpolación por Splines de a bloques}

A diferencia del método anterior, en este caso vamos a querer aplicar la técnica de Splines a bloques de pixeles de tamaño fijo. Es decir, para una misma posición del video, en vez de utilizar todos los valores del pixel a través del tiempo, generamos splines entre particiones de la misma longitud. El procedimiento es:

\begin{lstlisting}
Sean W,H,I el ancho, alto y la cantidad de frames del video original
Sea video[W][H][I] el triple vector de numeros enteros que representa el video original
Sea K la cantidad de frames que queremos agregar entre cuadro y cuadro
Sea T el tamano de bloque de los Splines
Observacion: reutilizamos el metodo GenerarSpline() de los Splines normales
Observacion: asumimos que I es divisible por T para simplificar este pseudocodigo

Crear un triple vector de enteros new_video[W][H][I+(I-1)*K]
Para w = 0 hasta W-1 hacer
	Para h = 0 hasta H-1 hacer
		Para t = 0 hasta T-1 hacer
			Crear subvector aux[T] = video[w][h][T*t..T*(t+1)-1]
			Crear vector bloque[T+(T-1)*K]
			GenerarSpline(aux, bloque, T, K)
			Pushear a new_video[w][h] todos los elementos de 'bloque' excepto el ultimo
		Fin para
		new_video[w][h].push_back(video[w][h][I-1])
	Fin para
Fin para
Devolver new_video
\end{lstlisting}
